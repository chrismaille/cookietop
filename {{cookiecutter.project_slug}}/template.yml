AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: {{ cookiecutter.project_description }}

Globals:
  Function:
    Runtime: python{{ cookiecutter.python_version }}
    Tracing: Active
    Layers:
      - Ref: {{cookiecutter.project_name_camel}}DepLayer
      {% if cookiecutter.database == "RDS" or cookiecutter.database == "Both" %}
      - arn:aws:lambda:us-east-1:898466741470:layer:psycopg2-py37:3
      {% endif %}
    Environment:
      Variables:
        # Use file local.json to override these values in sam local start-api
        {% raw %}
        ENVIRONMENT: '{{resolve:ssm:NoverdeEnvironment:1}}'
        LOGGER_LEVEL: '{{resolve:ssm:/{% endraw %}{{cookiecutter.project_name_camel}}{% raw %}/settings/logLevel:1}}'
        SENTRY_ENDPOINT: '{{resolve:ssm:/{% endraw %}{{cookiecutter.project_name_camel}}{% raw %}/endpoints/sentry:1}}'
        DATABASE_SQL_URL: '{{resolve:ssm:/{% endraw %}{{cookiecutter.project_name_camel}}{% raw %}/endpoints/rds:1}}'
        DATABASE_NOSQL_URL: !GetAtt [ {% endraw %}{{cookiecutter.domain_class}}{% raw %}Document, Arn ]
        {% endraw %}
  Api:
    Cors:
      AllowOrigin: "'*'"
      AllowHeaders: "'Content-Type,Authorization'"

Resources:
  # Request Lambda Authorizer
  ApiLambdaAuthorizer:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: {{cookiecutter.project_slug}}-api-lambda-authorizer
      CodeUri: {{cookiecutter.project_slug}}
      Handler: interface.handlers.authorize.authorize
      Environment:
        Variables:
          {% raw %}
          AUTHORIZATION_TOKEN: '{{resolve:ssm:/{% endraw %}{{cookiecutter.project_name_camel}}{% raw %}/secrets/access_token:1}}'
          {% endraw %}
      Policies:
        - AWSLambdaFullAccess
        {% if cookiecutter.database == "RDS" or cookiecutter.database == "Both" %}
        - AmazonRDSDataFullAccess
        {% endif %}
  # API Gateway Handlers
  HealthCheck:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: {{cookiecutter.project_slug}}-health-check
      CodeUri: {{cookiecutter.project_slug}}
      Handler: application.handlers.health.health_check
      Policies:
        - AWSLambdaFullAccess
        {% if cookiecutter.database == "RDS" or cookiecutter.database == "Both" %}
        - AmazonRDSDataFullAccess
        {% endif %}
      Events:
        GetHealth:
          Type: Api
          Properties:
            Path: /health
            Method: get
            RestApiId:
              Ref: {{cookiecutter.project_name_camel}}Api
  Create{{cookiecutter.domain_class}}:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: create_{{cookiecutter.domain_slug}}
      CodeUri: {{cookiecutter.project_slug}}
      Handler: application.handlers.create_{{cookiecutter.domain_slug}}.create
      Policies:
        - AWSLambdaFullAccess
        {% if cookiecutter.database == "RDS" or cookiecutter.database == "Both" %}
        - AmazonRDSDataFullAccess
        {% endif %}
      Events:
        Post{{cookiecutter.domain_class}}:
          Type: Api
          Properties:
            Path: /{{cookiecutter.domain_slug}}s
            Method: post
            RestApiId:
              Ref: {{cookiecutter.project_name_camel}}Api
  Retrieve{{cookiecutter.domain_class}}:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: retrieve_{{cookiecutter.domain_slug}}
      CodeUri: {{cookiecutter.project_slug}}
      Handler: application.handlers.retrieve_{{cookiecutter.domain_slug}}.retrieve
      Policies:
        - AWSLambdaFullAccess
        {% if cookiecutter.database == "RDS" or cookiecutter.database == "Both" %}
        - AmazonRDSDataFullAccess
        {% endif %}
      Events:
        Retrieve{{cookiecutter.domain_class}}:
          Type: Api
          Properties:
            Path: /{{cookiecutter.domain_slug}}s/{uuid}
            Method: get
            RequestParameters:
              method.request.path.uuid:
                Required: true
                Caching: false
            RestApiId:
              Ref: {{cookiecutter.project_name_camel}}Api
  Update{{cookiecutter.domain_class}}:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: update_{{cookiecutter.domain_slug}}
      CodeUri: {{cookiecutter.project_slug}}
      Handler: application.handlers.update_{{cookiecutter.domain_slug}}.update
      Policies:
        - AWSLambdaFullAccess
        {% if cookiecutter.database == "RDS" or cookiecutter.database == "Both" %}
        - AmazonRDSDataFullAccess
        {% endif %}
      Events:
        Update{{cookiecutter.domain_class}}:
          Type: Api
          Properties:
            Path: /{{cookiecutter.domain_slug}}s/{uuid}
            Method: post
            RequestParameters:
              method.request.path.uuid:
                Required: true
                Caching: false
            RestApiId:
              Ref: {{cookiecutter.project_name_camel}}Api

  # Step Functions Handlers
  Find{{cookiecutter.domain_class}}Instance:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: {{cookiecutter.project_slug}}-find-{{cookiecutter.domain_slug}}-step
      CodeUri: {{cookiecutter.project_slug}}
      Handler: application.machines.create_{{cookiecutter.domain_slug}}.find_{{cookiecutter.domain_slug}}_step.find_step
      Policies:
        - AWSLambdaFullAccess
        {% if cookiecutter.database == "RDS" or cookiecutter.database == "Both" %}
        - AmazonRDSDataFullAccess
        {% endif %}
      Role: !GetAtt [ LambdaExecutionRole, Arn ]

  Create{{cookiecutter.domain_class}}Instance:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: {{cookiecutter.project_slug}}-create-{{cookiecutter.domain_slug}}-step
      CodeUri: {{cookiecutter.project_slug}}
      Handler: application.machines.create_{{cookiecutter.domain_slug}}.create_{{cookiecutter.domain_slug}}_step.create_step
      Policies:
        - AWSLambdaFullAccess
        {% if cookiecutter.database == "RDS" or cookiecutter.database == "Both" %}
        - AmazonRDSDataFullAccess
        {% endif %}
      Role: !GetAtt [ LambdaExecutionRole, Arn ]

  Update{{cookiecutter.domain_class}}Instance:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: {{cookiecutter.project_slug}}-update-{{cookiecutter.domain_slug}}-step
      CodeUri: {{cookiecutter.project_slug}}
      Handler: application.machines.create_{{cookiecutter.domain_slug}}.update_{{cookiecutter.domain_slug}}_step.update_step
      Policies:
        - AWSLambdaFullAccess
        {% if cookiecutter.database == "RDS" or cookiecutter.database == "Both" %}
        - AmazonRDSDataFullAccess
        {% endif %}
      Role: !GetAtt [ LambdaExecutionRole, Arn ]

  # Step Function Machine
  {{cookiecutter.domain_class}}CreateMachine:
    Type: "AWS::StepFunctions::StateMachine"
    Properties:
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn: !GetAtt [ {{cookiecutter.domain_class}}CreateMachineLogGroup, Arn ]
        IncludeExecutionData: true
        Level: ALL
      DefinitionString: !Sub |
        {
          "Comment": "Create oor Update {{cookiecutter.domain}} State Machine",
          "StartAt": "Find {{cookiecutter.domain}}",
          "States": {
            "Find {{cookiecutter.domain}}": {
              "Type": "Task",
              "Resource": "${FindMydomainInstance.Arn}",
              "Next": "{{cookiecutter.domain}} exists?"
            },
            "{{cookiecutter.domain}} exists?": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.exists",
                  "BooleanEquals": true,
                  "Next": "Update {{cookiecutter.domain}}"
                }
              ],
              "Default": "Create new {{cookiecutter.domain}}"
            },
            "Update {{cookiecutter.domain}}": {
              "Type": "Task",
              "Resource": "${UpdateMydomainInstance.Arn}",
              "Next": "Success"
            },
            "Create new {{cookiecutter.domain}}": {
              "Type": "Task",
              "Resource": "${CreateMydomainInstance.Arn}",
              "Next": "Success"
            },
            "Success": {
              "Type": "Succeed"
            }
          }
        }
      RoleArn: !GetAtt [ StatesExecutionRole, Arn ]
      # ALWAYS use "EXPRESS" unless you know what your doing
      # https://docs.aws.amazon.com/step-functions/latest/dg/concepts-standard-vs-express.html
      StateMachineType: "EXPRESS"

  # Step Function Log Group
  {{cookiecutter.domain_class}}CreateMachineLogGroup:
    Type: "AWS::Logs::LogGroup"
    Properties:
      RetentionInDays: 1

  # Lambda Layer Configuration
  {{cookiecutter.project_name_camel}}DepLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: sam-{{cookiecutter.project_slug}}-dependencies
      Description: Dependencies for sam app [{{cookiecutter.project_slug}}]
      ContentUri: dependencies
      CompatibleRuntimes:
        - python3.7
      LicenseInfo: 'MIT'

  # Api Gateway Configuration
  {{cookiecutter.project_name_camel}}Api:
    Type: AWS::Serverless::Api
    Properties:
      Name: {{cookiecutter.project_name_camel}}Api
      OpenApiVersion: "3.0.3"
      TracingEnabled: true
      StageName: v1
      Auth:
        DefaultAuthorizer: RequestLambdaAuthorizer
        Authorizers:
          RequestLambdaAuthorizer:
            FunctionArn: !GetAtt ApiLambdaAuthorizer.Arn
  {% if cookiecutter.database == "DynamoDB (recommended)" or cookiecutter.database == "Both" %}
  # DynamoDB Table
  {{cookiecutter.domain_class}}Document:
    Type: "AWS::DynamoDB::Table"
    Properties:
      TableName: "{{cookiecutter.project_slug}}_{{ cookiecutter.domain_class }}Document"
      AttributeDefinitions:
        - AttributeName: uuid
          AttributeType: S
        - AttributeName: created
          AttributeType: S
        - AttributeName: rule
          AttributeType: S
      KeySchema:
        - AttributeName: uuid
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST
      GlobalSecondaryIndexes:
        - IndexName: search_by_date
          KeySchema:
            - AttributeName: uuid
              KeyType: HASH
            - AttributeName: created
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        - IndexName: search_by_rule
          KeySchema:
            - AttributeName: uuid
              KeyType: HASH
            - AttributeName: rule
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
  {% endif %}
  # IAM Roles
  LambdaExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: !Sub lambda.${AWS::Region}.amazonaws.com
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: AccessXRayFromLambda
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Action:
                  - "xray:PutTraceSegments"
                  - "xray:PutTelemetryRecords"
                Effect: Allow
                Resource: "*"
        - PolicyName: LambdaWriteLogs
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Action:
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Effect: Allow
                Resource: "*"
        {% if cookiecutter.database == "DynamoDB (recommended)" or cookiecutter.database == "Both" %}
        - PolicyName: AccessDynamoDBFromLambda
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Action:
                  - "dynamodb:Query"
                  - "dynamodb:Scan"
                  - "dynamodb:GetItem"
                  - "dynamodb:PutItem"
                  - "dynamodb:UpdateItem"
                  - "dynamodb:DeleteItem"
                  - "dynamodb:DescribeTable"
                Effect: Allow
                Resource: "*"
        {% endif %}

  StatesExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service:
                - !Sub states.${AWS::Region}.amazonaws.com
            Action: "sts:AssumeRole"
      Path: "/"
      Policies:
        - PolicyName: StatesExecutionPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "lambda:InvokeFunction"
                Resource: "*"
        - PolicyName: StatesAccessLogPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "logs:CreateLogDelivery"
                  - "logs:GetLogDelivery"
                  - "logs:UpdateLogDelivery"
                  - "logs:DeleteLogDelivery"
                  - "logs:ListLogDeliveries"
                  - "logs:PutResourcePolicy"
                  - "logs:DescribeResourcePolicies"
                  - "logs:DescribeLogGroups"
                Resource: "*"