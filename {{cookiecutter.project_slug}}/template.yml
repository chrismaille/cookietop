AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: {{ cookiecutter.project_description }}

Globals:
  Function:
    Runtime: python{{ cookiecutter.python_version }}
    # Timeout: 3  # Default value
    # MemorySize: 128  # Default value
    Tracing: Active
    Layers:
      - Ref: {{cookiecutter.project_name_camel}}DepLayer
      {% if cookiecutter.database == "RDS" or cookiecutter.database == "Both" %}
      - arn:aws:lambda:us-east-1:898466741470:layer:psycopg2-py37:3
      {% endif %}
    Environment:
      Variables:
        # Use file local.json to override these values in sam local start-api
        {% raw %}
        ENVIRONMENT: '{{resolve:ssm:NoverdeEnvironment:1}}'
        LOGGER_LEVEL: '{{resolve:ssm:/{% endraw %}{{cookiecutter.project_name_camel}}{% raw %}/settings/logLevel:1}}'
        SENTRY_ENDPOINT: '{{resolve:ssm:/{% endraw %}{{cookiecutter.project_name_camel}}{% raw %}/endpoints/sentry:1}}'{% endraw %}
        {% if cookiecutter.database == "RDS" or cookiecutter.database == "Both" %}
        DATABASE_SQL_URL: {% raw %}'{{resolve:ssm:/{% endraw %}{{cookiecutter.project_name_camel}}{% raw %}/endpoints/rds:1}}'{% endraw %}
        {% endif %}
        {% if cookiecutter.database == "DynamoDB (recommended)" or cookiecutter.database == "Both" %}
        DATABASE_NOSQL_TABLE_NAME: "{{cookiecutter.project_slug}}-{% raw %}{{resolve:ssm:NoverdeEnvironment:1}}{% endraw %}-{{ cookiecutter.domain_class }}Document"
        {% endif %}
  Api:
    Cors:
      AllowOrigin: "'*'"
      AllowMethods: "'OPTIONS,POST,GET,DELETE'"
      AllowHeaders: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,Authorization'"

Resources:
  # API Gateway Handlers
  HealthCheck:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: {{cookiecutter.project_slug}}-api_gateway-health-check
      CodeUri: {{cookiecutter.project_slug}}
      Handler: application.handlers.health.health_check
      Policies:
        - AWSLambdaFullAccess
        {% if cookiecutter.database == "RDS" or cookiecutter.database == "Both" %}
        - AmazonRDSDataFullAccess
        {% endif %}
      Events:
        GetHealth:
          Type: Api
          Properties:
            Path: /health
            Method: get
            RestApiId:
              Ref: {{cookiecutter.project_name_camel}}Api
  Create{{cookiecutter.domain_class}}:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: {{cookiecutter.project_slug}}-api_gateway-create_{{cookiecutter.domain_slug}}
      CodeUri: {{cookiecutter.project_slug}}
      Handler: application.handlers.create_{{cookiecutter.domain_slug}}.create
      Policies:
        - AWSLambdaFullAccess
        {% if cookiecutter.database == "RDS" or cookiecutter.database == "Both" %}
        - AmazonRDSDataFullAccess
        {% endif %}
      Events:
        Post{{cookiecutter.domain_class}}:
          Type: Api
          Properties:
            Path: /{{cookiecutter.domain_slug}}s
            Method: post
            RestApiId:
              Ref: {{cookiecutter.project_name_camel}}Api
  Retrieve{{cookiecutter.domain_class}}:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: {{cookiecutter.project_slug}}-api_gateway-retrieve_{{cookiecutter.domain_slug}}
      CodeUri: {{cookiecutter.project_slug}}
      Handler: application.handlers.retrieve_{{cookiecutter.domain_slug}}.retrieve
      Policies:
        - AWSLambdaFullAccess
        {% if cookiecutter.database == "RDS" or cookiecutter.database == "Both" %}
        - AmazonRDSDataFullAccess
        {% endif %}
      Events:
        Retrieve{{cookiecutter.domain_class}}:
          Type: Api
          Properties:
            Path: /{{cookiecutter.domain_slug}}s/{uuid}
            Method: get
            RequestParameters:
              method.request.path.uuid:
                Required: true
                Caching: false
            RestApiId:
              Ref: {{cookiecutter.project_name_camel}}Api
  Update{{cookiecutter.domain_class}}:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: {{cookiecutter.project_slug}}-api_gateway-update_{{cookiecutter.domain_slug}}
      CodeUri: {{cookiecutter.project_slug}}
      Handler: application.handlers.update_{{cookiecutter.domain_slug}}.update
      Policies:
        - AWSLambdaFullAccess
        {% if cookiecutter.database == "RDS" or cookiecutter.database == "Both" %}
        - AmazonRDSDataFullAccess
        {% endif %}
      Events:
        Update{{cookiecutter.domain_class}}:
          Type: Api
          Properties:
            Path: /{{cookiecutter.domain_slug}}s/{uuid}
            Method: post
            RequestParameters:
              method.request.path.uuid:
                Required: true
                Caching: false
            RestApiId:
              Ref: {{cookiecutter.project_name_camel}}Api
  StartCreate{{cookiecutter.domain_class}}Machine:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: {{cookiecutter.project_slug}}-api_gateway-start_create_{{cookiecutter.domain_slug}}_machine
      CodeUri: {{cookiecutter.project_slug}}
      Handler: application.handlers.start_create_{{cookiecutter.domain_slug}}_machine.start_machine
      Policies:
        - AWSLambdaFullAccess
        {% if cookiecutter.database == "RDS" or cookiecutter.database == "Both" %}
        - AmazonRDSDataFullAccess
        {% endif %}
      Role: !GetAtt [ LambdaHandleStepMachineRole , Arn ]
      Environment:
        Variables:
          CREATE_MACHINE_NAME: !GetAtt [ {{cookiecutter.domain_class}}CreateMachine , Name ]

  {% if cookiecutter.add_step_functions == "yes" %}
  # Step Functions Handlers
  Find{{cookiecutter.domain_class}}Instance:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: {{cookiecutter.project_slug}}-step_function-find-{{cookiecutter.domain_slug}}-step
      CodeUri: {{cookiecutter.project_slug}}
      Handler: application.machines.create_{{cookiecutter.domain_slug}}.find_{{cookiecutter.domain_slug}}_step.find_step
      Policies:
        - AWSLambdaFullAccess
        {% if cookiecutter.database == "RDS" or cookiecutter.database == "Both" %}
        - AmazonRDSDataFullAccess
        {% endif %}
      Role: !GetAtt [ LambdaExecutionRole, Arn ]

  Create{{cookiecutter.domain_class}}Instance:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: {{cookiecutter.project_slug}}-step_function-create-{{cookiecutter.domain_slug}}-step
      CodeUri: {{cookiecutter.project_slug}}
      Handler: application.machines.create_{{cookiecutter.domain_slug}}.create_{{cookiecutter.domain_slug}}_step.create_step
      Policies:
        - AWSLambdaFullAccess
        {% if cookiecutter.database == "RDS" or cookiecutter.database == "Both" %}
        - AmazonRDSDataFullAccess
        {% endif %}
      Role: !GetAtt [ LambdaExecutionRole, Arn ]

  Update{{cookiecutter.domain_class}}Instance:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: {{cookiecutter.project_slug}}-step_function-update-{{cookiecutter.domain_slug}}-step
      CodeUri: {{cookiecutter.project_slug}}
      Handler: application.machines.create_{{cookiecutter.domain_slug}}.update_{{cookiecutter.domain_slug}}_step.update_step
      Policies:
        - AWSLambdaFullAccess
        {% if cookiecutter.database == "RDS" or cookiecutter.database == "Both" %}
        - AmazonRDSDataFullAccess
        {% endif %}
      Role: !GetAtt [ LambdaExecutionRole, Arn ]

  # Step Function Machine
  {{cookiecutter.domain_class}}CreateMachine:
    Type: "AWS::StepFunctions::StateMachine"
    Properties:
      StateMachineName: {{cookiecutter.project_slug}}-CreateMachineState
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn: !GetAtt [ {{cookiecutter.domain_class}}CreateMachineLogGroup, Arn ]
        IncludeExecutionData: true
        Level: ALL
      DefinitionString: !Sub |
        {
          "Comment": "Create oor Update {{cookiecutter.domain}} State Machine",
          "StartAt": "Find {{cookiecutter.domain}}",
          "States": {
            "Find {{cookiecutter.domain}}": {
              "Type": "Task",
              "Resource": "${Find{{cookiecutter.domain_class}}Instance.Arn}",
              "Next": "{{cookiecutter.domain}} exists?"
            },
            "{{cookiecutter.domain}} exists?": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.exists",
                  "BooleanEquals": true,
                  "Next": "Update {{cookiecutter.domain}}"
                }
              ],
              "Default": "Create new {{cookiecutter.domain}}"
            },
            "Update {{cookiecutter.domain}}": {
              "Type": "Task",
              "Resource": "${Update{{cookiecutter.domain_class}}Instance.Arn}",
              "Next": "Success",
              "Retry": [ {
                 "ErrorEquals": [ "Lambda.ServiceException", "Lambda.AWSLambdaException", "Lambda.SdkClientException"],
                 "IntervalSeconds": 2,
                 "MaxAttempts": 6,
                 "BackoffRate": 2
              }],
              "Catch": [
              {
                  "ErrorEquals": [ "Lambda.Unknown" ],
                  "Next": "Mark Fail",
                  "ResultPath": "$.error"
              }]
            },
            "Create new {{cookiecutter.domain}}": {
              "Type": "Task",
              "Resource": "${Create{{cookiecutter.domain_class}}Instance.Arn}",
              "Next": "Success",
              "Retry": [ {
                 "ErrorEquals": [ "Lambda.ServiceException", "Lambda.AWSLambdaException", "Lambda.SdkClientException"],
                 "IntervalSeconds": 2,
                 "MaxAttempts": 6,
                 "BackoffRate": 2
              }],
              "Catch": [
              {
                  "ErrorEquals": [ "Lambda.Unknown" ],
                  "Next": "Mark Fail",
                  "ResultPath": "$.error"
              }]
            },
            "Mark Fail": {
              "Type": "Failure"
            },
            "Success": {
              "Type": "Succeed"
            }
          }
        }
      RoleArn: !GetAtt [ StatesExecutionRole, Arn ]
      StateMachineType: "EXPRESS"

  # Step Function Log Group
  {{cookiecutter.domain_class}}CreateMachineLogGroup:
    Type: "AWS::Logs::LogGroup"
    Properties:
      RetentionInDays: 1
  {% endif %}
  # Lambda Layer Configuration
  {{cookiecutter.project_name_camel}}DepLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: sam-{{cookiecutter.project_slug}}-dependencies
      Description: Dependencies for sam app [{{cookiecutter.project_slug}}]
      ContentUri: dependencies
      CompatibleRuntimes:
        - python3.7
      LicenseInfo: 'MIT'

  # Api Gateway Configuration
  {{cookiecutter.project_name_camel}}Api:
    Type: AWS::Serverless::Api
    Properties:
      Name: {{cookiecutter.project_name_camel}}Api
      OpenApiVersion: "3.0.3"
      TracingEnabled: true
      StageName: v1
      Auth:
        AddDefaultAuthorizerToCorsPreflight: False
        DefaultAuthorizer: RequestLambdaAuthorizer
        Authorizers:
          RequestLambdaAuthorizer:
            FunctionArn:
              Fn::ImportValue: profile-authorizer-arn
            Identity:
              ReauthorizeEvery: 300
      GatewayResponses:
        DEFAULT_4XX:
          StatusCode: 400
          ResponseParameters:
            Headers:
              Access-Control-Allow-Origin: "'*'"
              Access-Control-Allow-Headers: "'*'"
        DEFAULT_5XX:
          StatusCode: 500
          ResponseParameters:
            Headers:
              Access-Control-Allow-Origin: "'*'"
              Access-Control-Allow-Headers: "'*'"
        UNAUTHORIZED:
          StatusCode: 401
          ResponseParameters:
            Headers:
              Access-Control-Allow-Origin: "'*'"
              Access-Control-Allow-Headers: "'*'"
        ACCESS_DENIED:
          StatusCode: 403
          ResponseParameters:
            Headers:
              Access-Control-Allow-Origin: "'*'"
              Access-Control-Allow-Headers: "'*'"

  {% if cookiecutter.database == "DynamoDB (recommended)" or cookiecutter.database == "Both" %}
  # DynamoDB Table
  {{cookiecutter.domain_class}}Document:
    Type: "AWS::DynamoDB::Table"
    Properties:
      TableName: "{{cookiecutter.project_slug}}-{% raw %}{{resolve:ssm:NoverdeEnvironment:1}}{% endraw %}-{{ cookiecutter.domain_class }}Document"
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      AttributeDefinitions:
        - AttributeName: uuid
          AttributeType: S
        - AttributeName: created_at
          AttributeType: S
        - AttributeName: rule
          AttributeType: S
      # Good reads for Partition and Sort keys:
      # https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html
      # https://aws.amazon.com/pt/blogs/database/choosing-the-right-dynamodb-partition-key/
      KeySchema:
        - AttributeName: uuid
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST
      GlobalSecondaryIndexes:
        - IndexName: search_by_creation_date
            KeySchema:
              - AttributeName: created_at
                KeyType: HASH
            Projection:
              ProjectionType: ALL
  {% endif %}
  # IAM Roles
  LambdaExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: "lambda.amazonaws.com"
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: AccessXRayFromLambda
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Action:
                  - "xray:PutTraceSegments"
                  - "xray:PutTelemetryRecords"
                Effect: Allow
                Resource: "*"
        - PolicyName: LambdaWriteLogs
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Action:
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Effect: Allow
                Resource: "*"
        {% if cookiecutter.database == "DynamoDB (recommended)" or cookiecutter.database == "Both" %}
        - PolicyName: AccessDynamoDBFromLambda
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Action:
                  - "dynamodb:Query"
                  - "dynamodb:Scan"
                  - "dynamodb:GetItem"
                  - "dynamodb:PutItem"
                  - "dynamodb:UpdateItem"
                  - "dynamodb:DeleteItem"
                  - "dynamodb:DescribeTable"
                Effect: Allow
                Resource: "*"
        {% endif %}
  {% if cookiecutter.add_step_functions == "yes" %}
  StatesExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service: "lambda.amazonaws.com"
            Action: "sts:AssumeRole"
      Path: "/"
      Policies:
        - PolicyName: HandleSQSMessages
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Action:
                  - "sqs:ReceiveMessage"
                  - "sqs:DeleteMessage"
                  - "sqs:GetQueueAttributes"
                Effect: Allow
                Resource: "*"
        - PolicyName: StatesExecutionPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "lambda:InvokeFunction"
                Resource: "*"
        - PolicyName: StatesAccessLogPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "logs:CreateLogDelivery"
                  - "logs:GetLogDelivery"
                  - "logs:UpdateLogDelivery"
                  - "logs:DeleteLogDelivery"
                  - "logs:ListLogDeliveries"
                  - "logs:PutResourcePolicy"
                  - "logs:DescribeResourcePolicies"
                  - "logs:DescribeLogGroups"
                Resource: "*"

  LambdaHandleStepMachineRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: "lambda.amazonaws.com"
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: HandleStateMachinePolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Action:
                  - "states:ListStateMachines"
                  - "states:StartExecution"
                Effect: Allow
                Resource: "arn:aws:states:*:*:*"
{% endif %}